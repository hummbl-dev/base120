name: Governance Change Classifier

permissions:
  contents: read
  pull-requests: write
  issues: write

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  classify:
    runs-on: ubuntu-latest
    outputs:
      change_class: ${{ steps.classify.outputs.change_class }}
      impact_level: ${{ steps.classify.outputs.impact_level }}
      requires_audit: ${{ steps.classify.outputs.requires_audit }}
      min_reviewers: ${{ steps.classify.outputs.min_reviewers }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get changed files
        id: changed_files
        run: |
          # Get list of changed files in PR
          git fetch origin ${{ github.base_ref }}
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Classify changes
        id: classify
        run: |
          CHANGED_FILES="${{ steps.changed_files.outputs.changed_files }}"
          
          # Initialize classification variables
          CHANGE_CLASS="trivial"
          IMPACT_LEVEL=1
          REQUIRES_AUDIT="false"
          MIN_REVIEWERS=0
          
          # Check for breaking changes (highest priority)
          if echo "$CHANGED_FILES" | grep -qE "base120/.*\.py" && [ -f "tests/test_corpus.py" ]; then
            # Run a quick check to see if any tests would fail
            # This is a simplified check; actual breaking change detection requires running tests
            CHANGE_CLASS="potential-breaking"
            IMPACT_LEVEL=5
            REQUIRES_AUDIT="true"
            MIN_REVIEWERS=3
          fi
          
          # Check for FM/Registry changes
          if echo "$CHANGED_FILES" | grep -qE "registries/.*\.json|base120/validators/(mappings|errors|validate)\.py"; then
            CHANGE_CLASS="fm"
            IMPACT_LEVEL=5
            REQUIRES_AUDIT="true"
            MIN_REVIEWERS=2
          fi
          
          # Check for schema changes
          if echo "$CHANGED_FILES" | grep -qE "schemas/.*\.json|base120/validators/schema\.py"; then
            CHANGE_CLASS="schema"
            IMPACT_LEVEL=4
            REQUIRES_AUDIT="true"
            MIN_REVIEWERS=1
          fi
          
          # Check for corpus changes
          if echo "$CHANGED_FILES" | grep -qE "tests/corpus/"; then
            CHANGE_CLASS="corpus"
            IMPACT_LEVEL=3
            REQUIRES_AUDIT="true"
            MIN_REVIEWERS=0
            
            # Check if modifying existing corpus (requires additional review)
            if echo "$CHANGED_FILES" | grep -qE "tests/corpus/(valid|invalid)/.*\.json" && \
               git diff --name-status origin/${{ github.base_ref }}...HEAD | grep -qE "^M.*tests/corpus/"; then
              MIN_REVIEWERS=1
            fi
          fi
          
          # Check for documentation changes (lower priority overrides)
          if echo "$CHANGED_FILES" | grep -qE "^docs/|README\.md" && \
             ! echo "$CHANGED_FILES" | grep -qE "registries/|schemas/|base120/.*\.py|tests/corpus/"; then
            CHANGE_CLASS="editorial"
            IMPACT_LEVEL=2
            REQUIRES_AUDIT="false"
            MIN_REVIEWERS=0
          fi
          
          # Check for trivial changes (lowest priority)
          if echo "$CHANGED_FILES" | grep -qE "\.md$" && \
             ! echo "$CHANGED_FILES" | grep -qE "registries/|schemas/|base120/|tests/|examples/.*\.py"; then
            # Count non-markdown files
            NON_MD_COUNT=$(echo "$CHANGED_FILES" | grep -vE "\.md$" | wc -l)
            if [ "$NON_MD_COUNT" -eq 0 ]; then
              CHANGE_CLASS="trivial"
              IMPACT_LEVEL=1
              REQUIRES_AUDIT="false"
              MIN_REVIEWERS=0
            fi
          fi
          
          # Output classification
          echo "change_class=$CHANGE_CLASS" >> $GITHUB_OUTPUT
          echo "impact_level=$IMPACT_LEVEL" >> $GITHUB_OUTPUT
          echo "requires_audit=$REQUIRES_AUDIT" >> $GITHUB_OUTPUT
          echo "min_reviewers=$MIN_REVIEWERS" >> $GITHUB_OUTPUT
          
          echo "Classification: $CHANGE_CLASS (Level $IMPACT_LEVEL)"
          echo "Requires Audit: $REQUIRES_AUDIT"
          echo "Minimum Reviewers: $MIN_REVIEWERS"
      
      - name: Post classification comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const changeClass = "${{ steps.classify.outputs.change_class }}";
            const impactLevel = "${{ steps.classify.outputs.impact_level }}";
            const requiresAudit = "${{ steps.classify.outputs.requires_audit }}";
            const minReviewers = "${{ steps.classify.outputs.min_reviewers }}";
            
            const classDescriptions = {
              'trivial': 'Minor corrections with zero semantic impact (typos, formatting)',
              'editorial': 'Documentation restructuring or content expansion',
              'corpus': 'Adding or modifying test cases in the golden corpus',
              'schema': 'Changes to JSON schemas or validation rules',
              'fm': 'Changes to core validation logic, registries, or failure mode mappings',
              'potential-breaking': 'Changes that may break backward compatibility',
            };
            
            const evidenceRequirements = {
              'trivial': '- No evidence required',
              'editorial': '- Documentation builds successfully (if applicable)',
              'corpus': '- âœ… All existing tests pass\n- âœ… New tests pass\n- âœ… Corpus diff clearly shows changes\n- âœ… Justification in commit/PR description',
              'schema': '- âœ… Full test suite passes\n- âœ… Corpus diff shows impact\n- âœ… Backward compatibility analysis\n- âœ… Audit update in GOVERNANCE.md',
              'fm': '- âœ… Full test suite passes\n- âœ… Mathematical soundness proof\n- âœ… Impact analysis on all corpus cases\n- âœ… Audit update with rationale\n- âš ï¸ **v1.0.x: Registry changes PROHIBITED**',
              'potential-breaking': '- âœ… Full test suite passes\n- âœ… Migration guide for users\n- âœ… Audit update with detailed rationale\n- âœ… Version bump justification\n- âš ï¸ **v1.0.x: Breaking changes PROHIBITED**',
            };
            
            const comment = `## ðŸ” Governance Classification
            
            **Change Class:** \`${changeClass}\` (Impact Level: ${impactLevel})
            
            **Description:** ${classDescriptions[changeClass] || 'Unknown change class'}
            
            ### Evidence Requirements
            ${evidenceRequirements[changeClass] || 'No specific requirements'}
            
            ### Review Requirements
            - **Minimum Reviewers:** ${minReviewers} external + CODEOWNER approval
            - **Audit Update Required:** ${requiresAudit === 'true' ? 'âœ… Yes' : 'âŒ No'}
            
            ### Next Steps
            ${requiresAudit === 'true' ? '1. âœ… Ensure audit update in GOVERNANCE.md or CHANGELOG\n2. âœ… Provide impact analysis in PR description' : '1. âœ… Ensure documentation is clear and accurate'}
            3. âœ… Wait for required approvals (${minReviewers} + CODEOWNER)
            4. âœ… Address any CI check failures
            
            ---
            ðŸ“š See [GOVERNANCE.md](https://github.com/hummbl-dev/base120/blob/main/GOVERNANCE.md) for detailed requirements.
            `;
            
            // Find existing classification comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.data.find(c => 
              c.user.type === 'Bot' && c.body.includes('Governance Classification')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment,
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment,
              });
            }
